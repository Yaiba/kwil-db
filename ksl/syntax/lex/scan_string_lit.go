//line scan_string_lit.rl:1

package lex

// Code generated by scan_string_lit.rl; DO NOT EDIT.

//line scan_string_lit.go:9
var _kslstrtok_actions []byte = []byte{
	0, 1, 0, 1, 1, 2, 1, 0,
}

var _kslstrtok_key_offsets []byte = []byte{
	0, 0, 2, 4, 6, 8, 10, 12,
	15, 18, 21, 33, 42, 51, 60, 69,
	78, 87, 96,
}

var _kslstrtok_trans_keys []byte = []byte{
	128, 191, 128, 191, 128, 191, 10, 13,
	10, 13, 10, 13, 10, 13, 92, 10,
	13, 92, 10, 13, 92, 85, 117, 128,
	191, 192, 223, 224, 239, 240, 247, 248,
	255, 10, 13, 92, 48, 57, 65, 70,
	97, 102, 10, 13, 92, 48, 57, 65,
	70, 97, 102, 10, 13, 92, 48, 57,
	65, 70, 97, 102, 10, 13, 92, 48,
	57, 65, 70, 97, 102, 10, 13, 92,
	48, 57, 65, 70, 97, 102, 10, 13,
	92, 48, 57, 65, 70, 97, 102, 10,
	13, 92, 48, 57, 65, 70, 97, 102,
	10, 13, 92, 48, 57, 65, 70, 97,
	102,
}

var _kslstrtok_single_lengths []byte = []byte{
	0, 0, 0, 0, 2, 2, 2, 3,
	3, 3, 2, 3, 3, 3, 3, 3,
	3, 3, 3,
}

var _kslstrtok_range_lengths []byte = []byte{
	0, 1, 1, 1, 0, 0, 0, 0,
	0, 0, 5, 3, 3, 3, 3, 3,
	3, 3, 3,
}

var _kslstrtok_index_offsets []byte = []byte{
	0, 0, 2, 4, 6, 9, 12, 15,
	19, 23, 27, 35, 42, 49, 56, 63,
	70, 77, 84,
}

var _kslstrtok_indicies []byte = []byte{
	0, 1, 2, 1, 3, 1, 5, 6,
	4, 8, 9, 7, 10, 9, 7, 12,
	13, 14, 11, 16, 17, 18, 15, 0,
	17, 18, 15, 19, 20, 15, 2, 3,
	21, 15, 0, 16, 17, 18, 22, 22,
	22, 15, 16, 17, 18, 23, 23, 23,
	15, 16, 17, 18, 24, 24, 24, 15,
	16, 17, 18, 20, 20, 20, 15, 16,
	17, 18, 25, 25, 25, 15, 16, 17,
	18, 26, 26, 26, 15, 16, 17, 18,
	27, 27, 27, 15, 16, 17, 18, 0,
	0, 0, 15,
}

var _kslstrtok_trans_targs []byte = []byte{
	8, 0, 1, 2, 4, 5, 6, 4,
	5, 6, 5, 7, 8, 9, 10, 7,
	8, 9, 10, 11, 15, 3, 12, 13,
	14, 16, 17, 18,
}

var _kslstrtok_trans_actions []byte = []byte{
	0, 0, 0, 0, 0, 1, 1, 3,
	5, 5, 0, 0, 1, 1, 1, 3,
	5, 5, 5, 0, 0, 0, 0, 0,
	0, 0, 0, 0,
}

var _kslstrtok_eof_actions []byte = []byte{
	0, 0, 0, 0, 0, 3, 3, 0,
	3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3,
}

const kslstrtok_start int = 4
const kslstrtok_first_final int = 4
const kslstrtok_error int = 0

const kslstrtok_en_quoted int = 7
const kslstrtok_en_unquoted int = 4

//line scan_string_lit.rl:10

func ScanStringLit(data []byte, quoted bool) [][]byte {
	var ret [][]byte

//line scan_string_lit.rl:56

	// Ragel state
	p := 0          // "Pointer" into data
	pe := len(data) // End-of-data "pointer"
	ts := 0
	te := 0
	eof := pe

	var cs int // current state
	switch {
	case quoted:
		cs = kslstrtok_en_quoted
	default:
		cs = kslstrtok_en_unquoted
	}

	_ = ts
	_ = eof

	/*token := func () {
	    ret = append(ret, data[ts:te])
	}*/

//line scan_string_lit.go:131
	{
	}

//line scan_string_lit.go:135
	{
		var _klen int
		var _trans int
		var _acts int
		var _nacts uint
		var _keys int
		if p == pe {
			goto _test_eof
		}
		if cs == 0 {
			goto _out
		}
	_resume:
		_keys = int(_kslstrtok_key_offsets[cs])
		_trans = int(_kslstrtok_index_offsets[cs])

		_klen = int(_kslstrtok_single_lengths[cs])
		if _klen > 0 {
			_lower := int(_keys)
			var _mid int
			_upper := int(_keys + _klen - 1)
			for {
				if _upper < _lower {
					break
				}

				_mid = _lower + ((_upper - _lower) >> 1)
				switch {
				case data[p] < _kslstrtok_trans_keys[_mid]:
					_upper = _mid - 1
				case data[p] > _kslstrtok_trans_keys[_mid]:
					_lower = _mid + 1
				default:
					_trans += int(_mid - int(_keys))
					goto _match
				}
			}
			_keys += _klen
			_trans += _klen
		}

		_klen = int(_kslstrtok_range_lengths[cs])
		if _klen > 0 {
			_lower := int(_keys)
			var _mid int
			_upper := int(_keys + (_klen << 1) - 2)
			for {
				if _upper < _lower {
					break
				}

				_mid = _lower + (((_upper - _lower) >> 1) & ^1)
				switch {
				case data[p] < _kslstrtok_trans_keys[_mid]:
					_upper = _mid - 2
				case data[p] > _kslstrtok_trans_keys[_mid+1]:
					_lower = _mid + 2
				default:
					_trans += int((_mid - int(_keys)) >> 1)
					goto _match
				}
			}
			_trans += _klen
		}

	_match:
		_trans = int(_kslstrtok_indicies[_trans])
		cs = int(_kslstrtok_trans_targs[_trans])

		if _kslstrtok_trans_actions[_trans] == 0 {
			goto _again
		}

		_acts = int(_kslstrtok_trans_actions[_trans])
		_nacts = uint(_kslstrtok_actions[_acts])
		_acts++
		for ; _nacts > 0; _nacts-- {
			_acts++
			switch _kslstrtok_actions[_acts-1] {
			case 0:
//line scan_string_lit.rl:35

				// If te is behind p then we've skipped over some literal
				// characters which we must now return.
				if te < p {
					ret = append(ret, data[te:p])
				}
				ts = p

			case 1:
//line scan_string_lit.rl:43

				te = p
				ret = append(ret, data[ts:te])

//line scan_string_lit.go:230
			}
		}

	_again:
		if cs == 0 {
			goto _out
		}
		p++
		if p != pe {
			goto _resume
		}
	_test_eof:
		{
		}
		if p == eof {
			__acts := _kslstrtok_eof_actions[cs]
			__nacts := uint(_kslstrtok_actions[__acts])
			__acts++
			for ; __nacts > 0; __nacts-- {
				__acts++
				switch _kslstrtok_actions[__acts-1] {
				case 1:
//line scan_string_lit.rl:43

					te = p
					ret = append(ret, data[ts:te])

//line scan_string_lit.go:255
				}
			}
		}

	_out:
		{
		}
	}

//line scan_string_lit.rl:83

	if te < p {
		// Collect any leftover literal characters at the end of the input
		ret = append(ret, data[te:p])
	}

	// If we fall out here without being in a final state then we've
	// encountered something that the scanner can't match, which should
	// be impossible (the scanner matches all bytes _somehow_) but we'll
	// tolerate it and let the caller deal with it.
	if cs < kslstrtok_first_final {
		ret = append(ret, data[p:len(data)])
	}

	return ret
}
